package com.eomcs.oop.ex05.m;

// 이렇게 Sedan과 Truck의 경우처럼
// 여러 클래스의 공통점을 추출하여 수퍼 클래스를 정의하는 경우,
// 그 수퍼 클래스의 목표는 서브 클래스의 공통 기능을 물려주는 것이다.
// 처음부터 Car를 먼저 만들어 쓰다가 더 특별한 클래스가 필요해서
// Sedan이나 Truck을 만든 것이 아니라,
// 여러 클래스를 사용하다 보니 공통 분모가 보여서,
// 소스 코드의 유지보수가 쉽도록 
// 한 클래스로 모아두기 위해 만든 경우는
// 해당 클래스를 직접 사용할 이유가 없다.
//
// 특히 generalization을 수행하여 만든 수퍼 클래스의 경우
// 직접 사용할 목적으로 만든 클래스가 아니다.
// 단지 서브 클래스에 공통 기능을 물려주기 위해 존재하는 클래스이다.
// 이런 클래스들은 직접 사용하지 못하게 막는 것이 좋다.
//
// 클래스를 직접 사용하지 못하게 막고 
// 단지 서브 클래스를 만들어 사용하도록 제한하는 문법이
// "추상 클래스" 이다.
//
// 추상 클래스
// => 서브클래스에게 공통 기능을 상속해주는 목적으로 만든 클래스이다.
// => 직접 사용하지 않는 클래스이다.
// => 즉 개발자에게 이 클래스를 상속 받아 새 클래스를 만들어 쓰라는 의미다!
// => 보통 '일반화(generalization)' 과정에서 생성되는 클래스를 추상 클래스로 만든다.
// => 문법:
//      abstract class 클래스명 {...}
//
public abstract class Car { //변경자 MODIFIER - 서브클래스관리용이므로 직접쓸 필요없다. 이 키워드를 만다면 서브클래스를 써라 

  public Car() {
    super();
  }

  public void start() {
    System.out.println("시동 건다!");
  }

  public void shutdown() {
    System.out.println("시동 끈다!");
  }

  public void run() {  
    // 해당 메서드는 각각 서브클래스에서 메서드재정의 필요 - 세단과 트럭
    System.out.println("달린다.");
  }

}


// 추상메서드는 굳이 슈퍼클래스에서 정의할 필요가 없다. 단지 run() 이라는 메서드가 있다고 선언만 하면된다. 
//  정의(메서드구현)와 선언(메서드형식만 정하는 것)은 다르다. 
//  추상메서드(메서드선언) - 메서드시그너처만 작성한다. (리턴타입,메서드명,파라미터) - 서브클래스에게 구현을 강요하는 문법
//  메서드의 몸체를 만들지않기 때문에 {...} 인스턴스를 생성해서 메서드를 호출하는 일반클래스에는 둘 수 없다. 
// 오직 추상클래스(또는 인터페이스)만이 추상메서드를 가질 수 있다. 