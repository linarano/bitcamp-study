// inner class : 다른 멤버가 중첩 클래스 사용하기
package com.eomcs.oop.ex11.c;

class C {

  static void m1() {
    //스태틱 메서드 - 주소가 없다.  - 객체주소없이 호출할 수 있는 것 따라서 this변수가 없다. 
    // 스태틱 멤버는 인스턴스 멤버를 사용할 수 없다.
    //
    X obj; // 레퍼런스 선언은 가능!

    //    obj = new X(); // 컴파일 오류! 인스턴스 생성 불가능! // -C 클래스의 인스턴스 주소를 줘야함 - 이너클래스를 호출하려면 

    // 이유?
    // - 인스턴스 멤버를 사용하려면 인스턴스 주소가 있어야 한다.
    // - 스태틱 메서드는 인스턴스 주소를 담고 있는 this 변수가 존재하지 않는다.
  }

  /*
  void text() {
    this.m2();
  }
   */

  void m2() {
    // C클래스의 인스턴스 주소를 갖고있으므로 호출가능한것..
    // 인스턴스 메서드는 인스턴스 주소를 담고 있는 this 변수가 있다. - 호출될때 인스턴스 주소가 넘어옴 저장 
    // 그래서 inner class 를 사용할 수 있다.
    X obj = this.new X();
    obj.test();

    X obj2 = new X(); // 인스턴스 필드나 메서드와 마찬가지로 this를 생략할 수 있다.
    obj2.test();
  }

  class X {
    void test() {
      System.out.println("X.test()");
    }
  }
}

//이너클래스객체를 만들려면  바깥객체 주소가 필요해. 그러나 스태틱메서드는 주소를 담을 수 있는 변수가 없기때문에-> 스태틱 메서드에서 이너클래스 객체를 만들수없다!(단순히 넘어가지마라. 원리가 왜?)
// 인스턴스 메서드는 (바깥클래스의 주소를 줘야한다.->this필요 -> this.생략가능) 이너클래스의 객체를 맘대로 만들 수 있다. -> 디스가 생략된다는 의미

public class Exam0310 {

  public static void main(String[] args) {
    C.m1();

    // C outer = null; // - 널포인트익셉션에러가 뜬다 - 가리킬 주소가 없어서 
    C outer = new C();
    outer.m2();// 인스턴스 메서드이기 때문에 작업하려면 인스턴스 주소를 줘야! // 내장된 this에 C클래스의 객체의 주소를 넣는다. 따라서 주소가없으면 안된다.주소가 없으면 null
  } //   파라미터로 주소를 넘긴것 앞에 

}

//이 식이 성립하기 위한 전제조건  -메인부터  다 따라가면서 소스코드를 해석할 수 없다.
//인스턴스 메서드, 인스턴스 필드는 인스턴스 주소없이 절대 사용불가 
