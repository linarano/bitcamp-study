// 추상 클래스 레퍼런스와 메서드 호출
package com.eomcs.oop.ex07.a;

// 추상 메서드는 구현하지 않은 메서드이기 때문에
// 일반 클래스(=구현 클래스; concrete class)는 추상 메서드를 가질 수 없다.
// 오직 추상 클래스만이 추상 메서드를 가질 수 있다.
// 왜?
// - 일반 클래스는 인스턴스를 생성할 수 있다.
// - 인스턴스로 메서드를 호출하기 때문에
//   일반 클래스에 완전히 정의되지 않은 메서드가 있다면,
//   호출할 때 오류가 발생할 것이다.
// - 이런 문제를 발생시키지 않기 위해
//   일반 클래스는 추상 메서드를 갖지 않게 하였다.
//
abstract class A3 {
  public abstract void m1();
}

class A3Sub extends A3 {
  @Override // 이 애노테이션은 빼도 된다.
  public void m1() {
    System.out.println("A3Sub.m1() 호출됨!");
  }

  public void m2() {
    System.out.println("A3Sub.m2() 호출됨!");
  }
}

public class Exam03 {
  public static void main(String[] args) {
    A3 obj;

    // 추상 클래스의 인스턴스는 생성 불가!( 생성되지않은 메서드호출의 가능성을 막음)
    //        obj = new A3(); // Error!

    // 추상 메서드를 구현한 서브 클래스 만이 인스턴스 생성 가능!
    obj = new A3Sub();

    // 오버라이딩 규칙에 따라
    // - 레퍼런스가 실제 가리키는 객체의 클래스에서부터 메서드를 찾는다.(컴파일러와 실행구분!)
    obj.m1(); //(추상메서드호출이 아니라(호출은 실행의문제), 문법적으로 있냐없냐만 따지므로  컴파일러는 문제없음 , 서브클래스는 추상메서드를 구현했을것이므로)//2.실행할때  - 인스턴스의 실제클래스에 가서 찾아올라감

    // 참고!
    //
    // - 레퍼런스가 실제 가리키는 객체가 A3Sub 라 하더라도
    //   레퍼런스 타입의 범위를 넘어서 메서드를 호출할 수는 없다.
    //            obj.m2(); // 컴파일 오류! - 클래스파일이 안만들어지면 실행은 되지도 못함.실행은 그 이후 문제 

    // - 물론 실제 인스턴스 타입으로 형변환 후에는 가능한다.(컴파일러 통과시키는 방법) 단, 거짓말하면안됨 - 실행시 에러쓸 것 : 여기는 컴파일단계
    ((A3Sub)obj).m2();
  }

  static void test(A3 obj) { //빵 - 소보루빵, 단팥빵...//서브클래스의 메서드를 호출하겠다는 의미
    obj.m1();
    // 엥? 
    // obj는 A3의 레퍼런스이다.
    // A3의 m1() 은 추상 메서드이다.
    // 그런데 어떻게 m1() 을 호출하는가?
    //
    // 답변:
    // - A3는 추상 클래스이기 때문에 A3의 인스턴스는 생성할 수 없다.
    // - 따라서 obj 파라미터에 넘어오는 인스턴스(주소)는 
    //   A3의 인스턴스가 아니라 A3의 자식 클래스의 인스턴스일 것이다.
    // - 인스턴스를 만들었다는 의미는 A3의 자식 클래스로서 
    //   A3의 모든 추상 메서드를 구현했다는 의미다.
    // - 따라서 obj를 가지고 m1() 를 호출할 때는 
    //   실제 obj가 가리키는 인스턴스의 클래스에서 m1() 메서드를 찾아 호출한다.(실행의 문제)
    // - 다시 한 번 말하지만 인스턴스를 만들었다는 것은 
    //   일반 클래스라는 뜻이고,
    //   일반 클래스에는 추상 메서드가 없다.
    //   그러므로 A3를 상속 받은 일반 클래스는 반드시 m1() 메서드를 구현했다는 의미다.
    // 


  }

}

//컴파일을 통과하지못하면 클래스파일이 안만들어짐 
//추상클래스는 객체를만들수 없으므로 this에 들어갈 수 없음 

//컴파일러에서 통과되어 클래스가 만들어진후에야 비로소 클래스가 실행될 수 있음 -> 인스턴스가 생성되고, 그 주소가 담김.
//메서드호출은 자바버츄얼머신 문제
//자바버츄얼머신 - 실제 그주소를 찾아간다. 

//*** 주의!!!!! 메서드호출시 파라미터 값으로 주소를 줬었는데,
//마찬가지로 !!!!!
//메서드호출할때는 주소없이 할 수 없음!
//반드시 앞에 클래스가 오거나 인스턴스 주소가 와야함. 
//클래스.메서드()  클래스이름 생략
//인스턴스.메서드() this 생략/
// 컴파일러가 자동으로 붙여준다.!!!! 몰라도 상관없겠지만 원리를 제대로 이해해라. - 실무에서는 생략을 많이한다. 

//주소없이 호출할 수 있는 건 로컬변수밖에 안됨.
//스태틱변수, 인스턴스변수는 반드시 앞에 주소가 있어야함. this.content - this 생략

//시작점은 인스턴스주소부터 찾는다. ( 그래서 객체지향프로그램은 속도가 느릴수밖에 없음) 없으면 찾아올라감 

