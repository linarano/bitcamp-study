// inner class : 클래스 정의와 인스턴스 생성
package com.eomcs.oop.ex11.c;

class X {} // Top Level Class -패키지멤버 클래스 

class A {

  class X { // inner class - 오로지 논스태틱 네스티트 클래스!!! - 헷갈리지마라 스태틱 네스티트 클래스는 다르다. 
    // 컴파일러는 inner 클래스를 컴파일 할 때 다음과 같이 
    // - 바깥 클래스의 인스턴스 주소를 저장할 필드를 추가하고,
    // - 바깥 클래스의 인스턴스의 주소를 파라미터로 받는 생성자를 만든다.
    //
    //    A outer; //필드와 
    //    public X(A obj) { //생성자 
    //      this.outer = obj;
    //    } //스태틱때주면 컴파일러가 자동으로 생성해준다. 

  } //중첩클래스를 만들때 일단 STATIC을 붙이고 2) 뗄까요 안뗄까요??가 그다음 체크사항이어야한다. 3) 바깥클래스의 인스턴스 주소를 담아야하낟. 
  //중첩클래스의 경우 바깥클래스의 객체의 주소가 붙는 생성자가 새로 붙여진다. **
  //스태틱 클래스였다면 -> 우리가 직접 주소를 줘서 필드나 메서드를 호출했어야함. ㅠ.ㅐㅕㅛ()

  static class Y { }

  public class Exam0110 {

    public static void main(String[] args) {
      // 레퍼런스 선언
      A.X obj;
      A.Y obj2;

      // 인스턴스 생성
      //    obj = new A.X(); // 컴파일 오류!  바깥클래스의 주소가 없다.( 객체를 생성해야 주소를 준다.!!!)
      obj2 = new A.Y(); // 스태틱은 주소가 필요없다.

      //1) 바깥 클래스의 인스턴스 준비
      A outer = new A();//null; -> 객체를 생성해야 주소가 담기지 

      //2) 바깥 클래스의 인스턴스 주소를 사용하여 inner class의 인스턴스 생성
      obj = outer.new X(); // 컴파일러가 해준다다. new A.X(outer);

      // 컴파일러는 inner 클래스의 객체를 만드는 코드를 컴파일 할 때 다음과 같이 
      // - 바깥 클래스의 객체를 생성자에 전달하는 코드로 변경한다.
      // obj = new A.X(outer); // 이건 컴파일러용 
      //컴파일러가 해주니까 직접 이렇게 써주면 안된다. !!!!
    }

  }
}


